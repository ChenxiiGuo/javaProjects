/*This class works as the "monitor".
All buttons (non-control buttons), panes and fields are put here.
All the click even happened in the draw boarder are handled here.
* */

import javafx.application.Application;
import javafx.event.EventHandler;
import javafx.geometry.HPos;
import javafx.scene.Scene;
import javafx.scene.SnapshotParameters;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.ScrollPane;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.image.PixelWriter;
import javafx.scene.image.WritableImage;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Text;
import javafx.stage.Stage;


import java.util.Stack;


public class MainPanel extends Application{

    final int drawMaxW = 800;
    final int drawMaxH = 450;

    final int boarderWidth = 1050;


    //This class contains the information.
    // It is an important medium for different classes
    private DrawControl drawControl;


    //This class controls the main image shown in the drawing board
    private GalaryControl galaryControl;


    // Drawing board(a canvas) and main image are put here
    private GridPane paintGrid = new GridPane();

    // The result generated by area calculator are put here
    private AreaRecordPane areaRecordPane;

    public void start(Stage stage) {

        galaryControl = new GalaryControl();
        drawControl = new DrawControl(galaryControl);
        DrawControlPane controlPane = new DrawControlPane(drawControl);
        GridPane mainGrid = new GridPane();

        drawControl.setMainCanvas(myCanvas());


        ScrollPane gallaryGrid = new ScrollPane();
        gallaryGrid.setMinHeight(220);
        ImageGrid gallary = drawControl.getGallaryImages();
        gallaryGrid.getStylesheets().add("Style.css");
        gallaryGrid.setContent(gallary);


        areaRecordPane = new AreaRecordPane();


        ImageView MicroScope = new ImageView(new Image("/Graphics/Micro.png"));
        GridPane.setHalignment(MicroScope, HPos.CENTER);
        paintGrid.add(MicroScope, 0, 0);
        paintGrid.add(galaryControl.getMainImageGrid() , 0 , 0);
        paintGrid.add(drawControl.getMainCanvas(),0,0);
        paintGrid.getStylesheets().add("Style.css");
        paintGrid.getStyleClass().add("PaintPane");
        drawControl.setImage(paintGrid);


        GridPane boarderlineBar = new GridPane();
        setBoarderlineBar(boarderlineBar);



        mainGrid.add(paintGrid, 0 , 0);
        mainGrid.add(controlPane,1,0);
        mainGrid.add(boarderlineBar, 0 ,1, 2, 1);
        mainGrid.add(areaRecordPane, 1, 2);
        mainGrid.add(gallaryGrid, 0, 2);


        Scene mainScene = new Scene(mainGrid);
        stage.setScene(mainScene);
        stage.show();
    }

    //set the boarderline bar between the drawing board and gallery
    void setBoarderlineBar(GridPane boarderlineBar) {
        boarderlineBar.setMinHeight(20);
        boarderlineBar.setMinWidth(boarderWidth );
        boarderlineBar.setMaxWidth(boarderWidth );
        boarderlineBar.getStylesheets().add("Style.css");
        boarderlineBar.getStyleClass().add("BoardBar");

        buildConstraint(boarderlineBar, 40, 1, drawMaxW, 20);
        Image film = new Image ("/Graphics/film.png");
        ImageView filmView = new ImageView(film);
        filmView.setFitHeight(16);
        filmView.setFitWidth(28);

        Image areaImage = new Image("/Graphics/Area.png");
        ImageView areaView = new ImageView(areaImage);
        areaView.setFitWidth(28);
        areaView.setFitHeight(16);

        Text galleryText = new Text("Gallery");
        galleryText.getStyleClass().add("Gallery");

        boarderlineBar.add(filmView, 1 , 0);
        boarderlineBar.add(galleryText, 3, 0);
        boarderlineBar.add(areaView, 40, 0);

    }

    // fill a specific area.
    // it will fill the area until meet a closed boundary and the boundary must have the same color
    // if you don't click within the closed boundary, the whole image will be changed.
    void filler(double x, double y, Canvas canvas, WritableImage image) {
        Stack<Integer> xCoorStack = new Stack<>();
        Stack<Integer> yCoorStack = new Stack<>();

        if(image.getPixelReader().getColor((int)x, (int)y).equals(drawControl.getFillColor())) return;

        PixelWriter pixelWriter = canvas.getGraphicsContext2D().getPixelWriter();

        xCoorStack.push((int)x);
        yCoorStack.push((int)y);
        int mark[][] = new int[drawMaxW][drawMaxH];

        for (int i = 0; i < drawMaxW; i++) {
            for (int j = 0; j < drawMaxH; j++) {
                if(image.getPixelReader().getColor(i, j).equals(drawControl.getFillColor())) {
                    mark[i][j] = 1;
                }
            }
        }

        while(!xCoorStack.empty()) {
            int xCoor = xCoorStack.pop();
            int yCoor = yCoorStack.pop();
            pixelWriter.setColor(xCoor, yCoor, drawControl.getFillColor());
            mark[xCoor][yCoor] = 1;

            if (xCoor + 1 < drawMaxW && mark[xCoor + 1][yCoor] != 1) {
                xCoorStack.push(xCoor + 1);
                yCoorStack.push(yCoor);
            }
            if (xCoor - 1 > 0 && mark[xCoor - 1][yCoor] != 1) {
                xCoorStack.push(xCoor - 1);
                yCoorStack.push(yCoor);
            }
            if (yCoor + 1 < drawMaxH && mark[xCoor][yCoor + 1] != 1) {
                xCoorStack.push(xCoor);
                yCoorStack.push(yCoor + 1);
            }
            if (yCoor - 1 > 0 && mark[xCoor][yCoor - 1] != 1) {
                xCoorStack.push(xCoor);
                yCoorStack.push(yCoor - 1);
            }
        }
    }

    //This function is used to calculate the area
    //It will calculate the number of pixels which have the same color as
    //the color in (px, py). Besides, these pixels must be connected with (px, py)
    void calculate(double px, double py, WritableImage image) {
        int coorX = (int) px;
        int coorY = (int) py;
        Color areaColor = image.getPixelReader().getColor(coorX, coorY);
        int mark[][] = new int[drawMaxW][drawMaxH];

        Stack<Integer> xCoorStack = new Stack<>();
        Stack<Integer> yCoorStack = new Stack<>();
        xCoorStack.push(coorX);
        yCoorStack.push(coorY);
        int numOfPixels = 0;
        while (!xCoorStack.empty()) {
            numOfPixels++;
            int xCoor = xCoorStack.pop();
            int yCoor = yCoorStack.pop();
            mark[xCoor][yCoor] = 1;


            if (xCoor + 1 < drawMaxW && mark[xCoor + 1][yCoor] != 1
                    && image.getPixelReader().
                    getColor(xCoor + 1, yCoor).equals(areaColor)) {
                xCoorStack.push(xCoor + 1);
                yCoorStack.push(yCoor);
                mark[xCoor + 1][yCoor] = 1;
            }
            if (xCoor - 1 > 0 && mark[xCoor - 1][yCoor] != 1
                    && image.getPixelReader().
                    getColor(xCoor - 1, yCoor).equals(areaColor)) {
                xCoorStack.push(xCoor - 1);
                yCoorStack.push(yCoor);
                mark[xCoor - 1][yCoor] = 1;

            }
            if (yCoor + 1 < drawMaxH && mark[xCoor][yCoor + 1] != 1
                    && image.getPixelReader().
                    getColor(xCoor, yCoor + 1).equals(areaColor)) {
                xCoorStack.push(xCoor);
                yCoorStack.push(yCoor + 1);
                mark[xCoor][yCoor + 1] = 1;

            }
            if (yCoor - 1 > 0 && mark[xCoor][yCoor - 1] != 1
                    && image.getPixelReader().
                    getColor(xCoor, yCoor - 1).equals(areaColor)) {
                xCoorStack.push(xCoor);
                yCoorStack.push(yCoor - 1);
                mark[xCoor][yCoor - 1] = 1;

            }
        }

        int area = drawControl.getPpm() == 0 ?
                numOfPixels :numOfPixels / drawControl.getPpm();

        drawControl.setArea(area);
        areaRecordPane.addRecord(drawControl.getArea(), drawControl.getPpm());
        //System.out.println(numOfPixels);

    }



    Canvas myCanvas() {
        Canvas canvas = new Canvas();
        canvas.setHeight(drawMaxH);
        canvas.setWidth(drawMaxW);
        GraphicsContext gc = canvas.getGraphicsContext2D();

        canvas.setOnMouseClicked(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent me) {
                double px = me.getX();
                double py = me.getY();
                if (drawControl.isFillModel()) {
                    WritableImage image = drawControl.getImage().
                            snapshot(new SnapshotParameters(), null);
                    filler(px, py, canvas, image);
                }
                else if (drawControl.isCalculateArea()) {
                    WritableImage image = drawControl.getImage().
                            snapshot(new SnapshotParameters(), null);
                    calculate(px, py, image);

                }

            }
        });


        canvas.setOnMouseDragged(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent me) {
                if (!drawControl.isCalculateArea()) {
                    double px = me.getX();
                    double py = me.getY();
                    //gc.save();
                    if (drawControl.isEraser()) {
                        gc.clearRect(px, py, drawControl.getEraserSize(), drawControl.getEraserSize());
                    }
                    else if (!drawControl.isFillModel()){
                        gc.setFill(drawControl.penColor());
                        gc.fillRect(px, py, drawControl.getPenSize(), drawControl.getPenSize());
                    }
                }

            }
        });

        canvas.setOnMouseReleased(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent me) {
                drawControl.setImage(paintGrid);
                drawControl.addToCanvasHistory(drawControl.getMainCanvas());

            }
        });

        return canvas;

    }

    private void buildConstraint(GridPane grid, int colNum, int rowNum, int width, int height) {
        for (int i = 0; i < colNum; i++) {
            ColumnConstraints column = new ColumnConstraints(width/colNum);
            grid.getColumnConstraints().add(column);
        }
        for (int i = 0; i < rowNum; i++) {
            RowConstraints row = new RowConstraints(height/rowNum);
            grid.getRowConstraints().add(row);
        }
    }



    public static void main(String[] args) {

        launch(args);
    }


}
